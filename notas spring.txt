-dependencias para usar: spring web, spring boot devtools
-las clases se crean desde la vista "java projects"
-las anotaciones (@) son etiquetas que se agregan a clases, métodos y campos para describirlos. Simplifican el proceso de crear aplicaciones.
-método handler: el que maneja las peticiones
- el Model de la instancia que se le inyecta a la vista desde el controlador es de la libreria de Spring; se puede usar un Map en vez de Model y es exactamente la misma lógica (especificar lso tipos genéricos y usar put en vez de addAttribute)
- un objeto Map es ideal para crear un json con atributos clave-valor y devolverlo (@ResponseBody dentro de @RestController asume esa semantica)
- @ResquestMapping: agregar una ruta por defecto
- @RestController = @Controller, @ResponseBody (este va antes del metoo y después del @GetMapping) si se separan, pdoriamos tener algunos métodos con thymeleaf y otros con api en el mismo controdor, pero no es lo mas típico.
- @GetMapping = @RequestMapping(method = RequestMethod.GET) poniendo además el atributo path, donde se especifica la url
- en el thymeleaf, si bien name es privado, cuando accedemos a user.name, por detrás esta accediendo al getter (pone el get y la n mayuscula); esta convención se aplica en todo el ecosistema de Spring (y Java en general).
- POJO: (plain old java object): objeto simpe de java, con getters/stters, que no dependen de un framework en especial
- cuando trabajamos con thymeleaf (plantillas) no hace falta usar DTO porque los datos no viajan al cliente, directamente se renderizan en el servidor
- el DTO permite crear estructuras de datos independientes del modelo de datos, para transportar datos entre componentes y reducir el numero de llamadas. 
- uno puede ir personalizando el dto, para enviarlo con una forma determinado, por ejemplo el nombre y el apellido juntos: userDto.setName(user.getName().concat(" ").concat(user.getLastname())
- List<User> users = Arrays.asList(user, user2, user3); es una clase helper de array para no tener que crear el arraylist y añadir en otras lineas cada elemento; pero ojo que es de tamaño fijo, no permite agregar ni remover (da un java.lang.UnsupportedOperationException); para eso, habría que hacer: List<User> users = new ArrayList<>(Arrays.asList(user, user2, user3));
-thymeleaf:  <li th:if="${user.email != null}" th:text="${user.email}"></li>   (si user.email es distinto de null, lo muestra)
o <li th:if="${user.email}" th:text="${user.email}"></li>                               
-thymeleaf: "${}" indica contexto java
-thymealeaf: <li th:if="${user.email == null}" th:text="${'no tiene email'}"></li> si se cumple la condicion, muestra ese texto por defecto
-thymeleaf: <li th:if="${user.email}" th:text="${user.email}"></li>
            <li th:if="${user.email == null}" th:text="${'no tiene email'}"></li>    seria una estructura if...else  se puede usar if-unless tambien
-thymeleaf: <tr th:each="user: ${users}">
                <td th:text="${user.name}"></td>
                <td th:text="${user.lastname}"></td>
                <td th:text="${user.email}"></td>
            </tr>                                           ejemplo de uso de each para iterar listas


- public User(String name, String lastname, String email) {
        this(name, lastname);
        this.email = email;
    }

    public User(String name, String lastname) {
        this.name = name;
        this.lastname = lastname;
    }                                      sobrecarga de constructores, el this(name,lastname) llama a otro constructor de la misma clase que contenga esos parametros en su firma, parecido a lo que se hace cuando se llama a una clase padre con super(arg1, arg2,..., argn); el orden del so constructores no importa

-conviene agregar tambien un constructor vacio para que el compilador no se queje si no pasamos argumentos cuando hacemos un new y porque algunos frameworks lo requieren para hacer reflexion o instanciar clases por detras

-no sabes cuantos argumentos va a recibir el constructor o metodo? usas varargs (tres puntos en la definicion del parametro, luego de su tipo: Tipo... nombre_argumento), solo peude haber uno por firma y va al final
ejemplo:    public class Grupo {
    private List<String> integrantes;

    public Grupo(String... nombres) {
        this.integrantes = Arrays.asList(nombres);
    }
}

- @ModelAttribute: antes de un método para definir atributos globales que pueden ser usados por distintas plantillas que maneja el controlador, también se puede usar antes del parámetro de un método

- @RequestParam: vincula un parámetro de un método a un param query, por defecto es requerido (se puede cambiar con required = false) y se puede dar un valor por defecto con defaultValue (implicitamente pasa required a false si usamos este ultimo parametro), name cambia el nombre del query, pero por convención el query param se debería llamar igual que el parámetro del metodo:
 public ParamDto foo(@RequestParam(defaultValue = "Hola", name = mensaje) String message) {...


--HttpServletRequest es el objeto que extrae los parámetros y todo lo relacionado con la request (cabeceras, sesiones, etc.)

ParamMixDto params = new ParamMixDto();
        params.setCode(Integer.parseInt(request.getParameter("code")));
        params.setMessage(request.getParameter("message"));

si no pasamos el code en la query da error porque no puede parsear nulo a integer, si en el code se pasa un string, también da error, porque parseInt convierte de int a Integer

	 @GetMapping("/request")
    public ParamMixDto request(HttpServletRequest request) {
        Integer code = 10;
        try {
            code = Integer.parseInt(request.getParameter("code"));
        } catch (NumberFormatException e) {

        }

        ParamMixDto params = new ParamMixDto();
        params.setCode(code);
        params.setMessage(request.getParameter("message"));

        return params;
    }

asi podemos salvar el posible error y crear un valor por defecto; forma mas artesanal en vez de usar @RequestParam; con @RequestParam mas adelante vamos a ver formas de salvar estos errores de tipo

@PathVariable: vincula un parámetro del método a una variable de la URI, se puede usar name atmbien para cambiar el nombre de la variable (y que no coincida con el del parámetro, pero sigue siendo convención que coincidan)

@GetMapping("/baz/{message}")
    public ParamDto baz(@PathVariable String message) {

        ParamDto param = new ParamDto();
        param.setMessage(message);

        return param;
    }

- @RequestBody: siempre que coincidan los datos recibidos con los atributos de una clase, van a matchear; la clase debe tener un constructor vacio y métodos set para que el objeto se pueda poblar

public User create(@RequestBody User user) {

        return user;
        
    }

- @JsonInclude(JsonInclude.Include.NON_NULL) en la clase si quiero que Jackson no incluya elementos nulos en el json al devolver la respuesta, cuanod se usa @ResquestBody

- @Value: anotación para inyectar valores desde archivos de configuracion externos a propiedades de clase o parámetros de metodo

@Value("${config.username}")
    private String username;

public Map<String, Object> values(@Value("${config.mensaje}") String mensaje) {...

-  @SpringBootApplication
   @PropertySource("classpath:values.properties")
   public class SpringbootWebApplication {...
   
   @PropertySource: le indica a Spring que cargue un archivo adicional de propiedades (en este caso, values.properties) y lo agregue al ambiente (Environment) de la aplicación (dentro de la carpeta Resources, y se puede usar @PropertySources para agregar mas de uno.

  @SpringBootApplication
@PropertySources({
		@PropertySource("classpath:values.properties"),
})
public class SpringbootWebApplication {

Otra forma es crear una clase de configuración aparte en la carpeta raíz de la app (hermana de SpringBootWebApplication, con la anotación @Configuration, asi no ensuciamos nuestra clase principal de Spring Boot
Ejemplo con clase ValuesConfig:
@Configuration
@PropertySources({
        @PropertySource("classpath:values.properties"),
})
public class ValuesConfig {

}

- cambiar la propiedad encoding si se rompen los caracteres:  @PropertySource(value = "classpath:values.properties", encoding = "UTF-8")
también se puede cambiar desde vscode, apretando UTF-8 (Select Encoding) en el panel inferior y cambiando a ISO 8859 1, pero no es tan estándar y es mas rebuscado

-Las SpEL empiezan con # y sirven para evaluar valores dinámicamente dentro de anotaciones, propiedades, plantillas y más.
@Value("#{ '${config.listOfValues}'.split(',')}")
    private List<String> valueList;

@Value("#{'${config.listOfValues}'.toUpperCase()}")
    private String valueString;

- @Value("#{${config.valuesMap}}")
    private Map<String, Object> valuesMap;   se usa la SpEL para poder evaluarlo como un map, objeto java, si no, se estaría trabajando con un string crudo; entonces, si solo se quieren inyectar valores escalares como int o String, no se usa SpEL; pero para ineyctar estructuras como Map o List, sí se usa

- Otra forma de inyectar es con la clase de Spring Environment: "@Autowired
    private Environment environment;" "json.put("message2", environment.getProperty("config.mensaje"));"

Spring te inyecta automáticamente un objeto de tipo Environment, que es parte del core de Spring y representa el entorno de ejecución de tu aplicación.
Este objeto:
Tiene acceso a todas las propiedades definidas en:
application.properties
application.yml
archivos adicionales (@PropertySource, perfiles, variables de entorno, etc.)
Te permite acceder a propiedades como si estuvieras usando @Value, pero de forma más programática.
el getProperty() devuelve por defecto todo como string
"json.put("code2", Integer.valueOf(environment.getProperty("config.code")));" asi lo casteamos a entero
"json.put("code2", environment.getProperty("config.code", Long.class));"; o asi, porque getProperty tiene sobrecarga de método
"Long code2 = environment.getProperty("config.code", Long.class);
json.put("code2", code2);"


-  @GetMapping({"", "/", "/home"})   se puede indicar varias rutas para ese get

- redirect: @GetMapping({"", "/", "/home"})
             public String home() {
              return "redirect:/list";
              // return "forward:/list";
            }                                   para redirigir a otra ruta existente en el proeycto, genera un neuvo request, reinicia la ruta y refresca el navegador
caso de uso: guardar una producto y redirigir al listado completo con el nuevo producto en el

- forward: se mantiene dentro de la misma petición, no se pierden los parámetros del request ni cambia la ruta, no hace un refresh;
dentro del mismo request, despacha a otro método handler

- deploy con consola: ./mvnw.cmd install: se usa cuando tenemos librerias o clases que querramos reutilizar en otros proyectos; si no, con usar package en vez de isntall, alcanza   (usar la palabra clean antes de install o package para limpiar el proeycto, evitar errores por archivos compilados viejos que quedaron en /target)
- luego, dentro de la carpeta target, con el comando java -jar (archivo jar, el que no dice original) levantamos el proyecto (asi hacemos un deploy, clave para produccion, ej.:  podemos isntalar el jdk en una instancia de EC2 en AWS y subir nuestro proyyecto)
- tambien se puede hacer el deploy de forma mas sencilla en vscode desde la pestaña maven en el panel derecho, en lifecycle (correr clean, luego package)
- si despeus de hacer un clean, da error al levantar el proyecto desde el spring dashboard, con un reload en la pestaña maven y se soluciona
- enlaces en thymeleaf: <a th:href="@{/list}">ver listado</a>       se usa @ que es para enlaces, $ es para objetos
para concatenar con ariables <a th:href="@{'/api/param/foo?message=' + ${title}}">ver mensaje</a>
<a th:href="@{/api/param/foo?message=Hola que tal festival}">ver mensaje2</a>
<a th:href="@{/api/param/foo(message='Hola que tal festival')}">ver mensaje3</a> forma propia de thymeleaf
<a th:href="@{/api/param/bar(text='Hola que tal festival', code=32332)}">ver mensaje4</a> con varios request params, si hay un objeto se usa el $
<a th:href="@{/api/var/baz/Hola algun mensaje}">ver mensaje5</a> para path variable
<a th:href="@{'/api/var/baz/' + ${title}}">ver mensaje6</a>





- di: dependency injection; librerias: Spring Web, Devtools, Actuator,
- constructor vacio: en caso de que queramos hacer el new sin parámetros y pasar los datos con el set
- al final de un valro de tipo Long se agrega "L"
- "return data.stream().filter(p -> p.getId().equals(id)).findFirst().orElse(null);" un stream, secuencia de elementos procesados de forma declarativa
- repository es la capa de acceso a datos (bdd, arraylist, json, datos de otra api) y service es la capa de lógica de negocio

    List<Product> findAll() {
        return repository.findAll().stream().map(p -> {
            Double priceImp = p.getPrice() * 1.25d;
            p.setPrice(priceImp.longValue());          //trabajamos con double xq es un decimal, pero volvemos a long porque es el tipo del precio
            return p;
        }).collect(Collectors.toList());     //transformar de nuevo a lista porque es un stream
    }

- no es recomendable usar el repository en el controlador, porque en el repository solo guardamos, leemos y obtenemos datos; en el controlador se puede realizar algunas manipulaciones de datos, pero no es función del controlador ensuciarse y acoplarse con tanta lógica de negocio

-  @RestController
@RequestMapping("/api")
public class SomeController {

    private ProductService productService = new ProductService();

    @GetMapping
    public List<Product> list() {

        return productService.findAll();


    }

    @GetMapping("/{id}")
    public Product show(@PathVariable Long id) {

        return productService.findById(id);
    }

}


-hacer las modificaciones en una copia del objeto para no modificar el original y violar el principio de inmutabilidad
public List<Product> findAll() {
        return repository.findAll().stream().map(p -> {
            Double priceImp = p.getPrice() * 1.25d;   // trabajamos con double xq es un decimal, pero volvemos a long porque es el tipo del precio
            Product newProduct = new Product(p.getId(), p.getName(), priceImp.longValue());
            //p.setPrice(priceImp.longValue()); asi no porque si no modificamos el precio original, violando el principio de inmutabilidad
            return newProduct;
        }).collect(Collectors.toList()); // transformar de nuevo a lista porque es un stream
    }
aclarar que esto ocurre porque estamos trabajando con el repositorio en memoria, en una bdd los datos se traen y no se cambian hasta que se haga el update en ella

- una forma mas elegante de evitar este problema es implementando la interfaz Cloneable en la clase del repositorio (hay que sobreescribir el método lone()

  @Override
    protected Object clone() {         // cambiar el protected por public
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            return new Product(id, name, price); //se puede hacer new Product(this.getId(), this.getName(), this.getPrice()) o sin el this, porque ajva asume que llamas al metodo del objeto actual; la forma con los getters es util si tienen lógica interna
        }
    }                                              asi si ocurre un error, se retorna igualmente una nueva instancia con los mismos datos (crear una copia manual si falla el clonado automático)
forma correcta con clone(): 
public List<Product> findAll() {
        return repository.findAll().stream().map(p -> {
            Double priceTax = p.getPrice() * 1.25d;
            Product newProd = (Product) p.clone();
            newProd.setPrice(priceTax.longValue()); // casteamos porque clone() devuelve un Object
            return newProd;
        }).collect(Collectors.toList()); // transformar de nuevo a lista porque es un stream
    }

- Al crear una interface, se puede ponerle una I delante del nombre, o cambiar el de la implementacion con el sufijo Impl, o con el de implementaciones concretas como JPA, JDC, API, Json, Array, List

- En los metodos de las interfaces no se especifican los modificadores de acceso porque por defecto son public

- El @Override sobre los metodos implementados de la interfaz no es obligatorio

- Los beans deben tener un constructor vacio, excepto que se inyecte con autowired mediante constructor

- Un bean permite crear objetos y registrarlos en el contenedor, pero mediante métodos

- Una clase anotada con el nombre Configuration indica que puede ser utilizada como una fuente de definiciones de beans por el contenedor de spring, va a tener una serie de métodos anotados con bean y t odo objeto que retornen se guardaran como componentes

    @Autowired
    private ProductRepositoryImpl repository;
    // private ProductRepositoryImpl repository = new ProductRepositoryImpl(); como
    // estamos trabajando con inyeccion de dependencias, no es necesario crearlo
    // nosotros con el new, sino que el contenedor de Spring provee el objeto

- Vamos a ver como implementarlo con interfaces para desacoplar las implementaciones, asi si el dia de mañana queremos cambiar la persistencia, solo hay que cambiar una linea de código.

 @Autowired
  private ProductRepository repository;  usamos el identificador mas abstracto, mas genérico, en este caso la interfaz
					después veremos como hacer si tenemos mas de una implemetnacion, para elegir la deseada

- @Service y @Repository son estereotipos semanticos de @Component (aunque @Repository se encarga asimismo de traducir la excepciones de bdd para que sean mas amistosas

 // @Autowired
    // public void setRepository(ProductRepository repository) {
    // this.repository = repository;
    // } //se puede usar el setter con el autowired también

// public ProductServiceImpl(ProductRepository repository) {
    //     this.repository = repository;
    // }        //con el constructor el Autowired es innecesario indicarlo

-Con @Primary elijo cual de las implementaciones de una interfaz se usara por defecto
@Primary
@Repository
public class ProductRepositoryImpl implements ProductRepository {...

-Puedo usar tambien @Qualifier("nombreDeLaImpl") cuando quiero especificar qué implementación usar al inyectar una dependencia:
public ProductServiceImpl(@Qualifier("productRepositoryImpl") ProductRepository repository) {
        this.repository = repository;
    } // con el constructor el Autowired es innecesario indicarlo

-En @Repository puedo cambiar el nombre lógico de la clase:    @Repository("otroRep")

-   @Autowired
    @Qualifier("productFoo") 
    private ProductRepository repository;       si queremos elegir una implementacion y estamos inyectando por atributo o por setter

- Si vamos a modificar los atributos del objeto original en una petición, podemos usar @RequestScope en la clase del repositorio para que su contexto sea la petición y no se mute este objeto (queda mutable por request pero inmutable para efectos de la aplicación)
No obstante, lo ideal continua siendo que se genere una copia del objeto al aplicar la lógica de negocio y el original se mantenga inmutable

- @SessionScope // para que cada sesión tenga su propia instancia

-  @Configuration
  @PropertySource("classpath:config.properties")
  public class AppConfig {

      @Bean("productJson")
      ProductRepository productRepositoryJson() {
          return new ProductRepositoryJson();
      }

  }
puedo usar los @Bean para registrar objetos en el contenedor desde un archivo de configuración a traves de métodos que devuelven instancias listas para inyectar (el public es innecesario)

-Clase para abrir archivo:

private List<Product> list;

public ProductRepositoryJson() {
        Resource resource = new ClassPathResource("json/products.json");
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            list = Arrays.asList(objectMapper.readValue(resource.getFile(), Product[].class));  //getInputStream() es lo mismo
        } catch (StreamReadException e) {
            e.printStackTrace();
        } catch (DatabindException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();                
        }
    }
Interfaz Resource para obtener recursos, ObjectMapper para convertir a objeto, con los métodos para obtener y leer los valores que iran en la lista ; recomienda encerrar todo en un try-catch para distintos errores que puedan surgir (de lectura, de mapeo y de existencia de archivo); puedo dejar tambien solo el IOException

- @Value para traer el json dentro de ProductRepositoryJson no sirve porque esa clase no es un componente de Spring. Podemos hacer el @Value en el archivo de configuracion y pasarselo a la clase por el metodo Bean. Tenemos entonces dos constructores en la clase, uno mas declarativo y otro mas programatico:

private List<Product> list;

    public ProductRepositoryJson() { // forma mas programática
        Resource resource = new ClassPathResource("json/products.json");
        readValueJson(resource);
    }

    public ProductRepositoryJson(Resource resource) { // forma mas declarativa
        readValueJson(resource);
    }

    private void readValueJson(Resource resource) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            list = Arrays.asList(objectMapper.readValue(resource.getFile(), Product[].class));
            // } catch (StreamReadException e) { //getInputStream() tambien funciona
            // e.printStackTrace();
            // } catch (DatabindException e) {
            // e.printStackTrace(); // con IOException esta bien
        } catch (IOException e) {
            e.printStackTrace();
        }

- Repaso de diagramado y diseño:   --Ver qué relaciones entre las clases nos interesan (entre cliente y factura, no me importa saber qué facturas tiene un cliente, entonces no es necesario un array de facturas en cliente; pero sí me interesa saber de qué cliente es una factura, entonces la factura conoce a cliente y lo tiene como atributo).
                                   --En los diagramas, la flecha direccionada va cuando uno se pregunta si una clase conoce a la otra
                                   --En el modelo relacional, al convertir DER a tablas, en una relación 1-M, se pone la clave foránea de la entidad madre en la entidad hija (la entidad hija es la que esta del lado de las patas de cuervo).
                                   --Cuando armo las relaciones, tanto en el modelo de dominio como el relacional, para establecer las cardinalidades en una relación, me paro una vez en cada elemento y me pregunto "este elemento tiene (o el verbo que sea) uno o varios del otro"
                                   --Item conoce a Product, pero no al reves; en el modelo de dominio Item tiene una asociación dirigida hacia Product y en el modelo relacional, Item tiene la clave foránea de Product (los atributos de Item son product y quantity, y de Product, name y price), porque seria también una relación 1:M (un producto puede estar en varios items, un item tiene un solo producto.


-No siempre un componente tiene que ser un servicio, controlador o repositorio, a veces puede ser otra clase, como un POJO (en el ejemplo, Invoice y Client son componentes también, que no necesitan un contrato con una interfaz).

-El componente no va a ser Item sino List<Item>, pero no podemos anotar a List<Item> como componente porque en el fondo es una instancia del tipo List. Lo que hacemos es crearla con la anotación @Bean en un método, en una clase configuration. La lista de items que devuelve el método es el componente.

Por qué no podemos hacer @Component sobre List<Item>?
Porque @Component solo se puede aplicar a clases propias o beans definidos por clases concretas.

List<Item> es una interfaz genérica de Java, no una clase concreta ni algo que Spring pueda detectar automáticamente como un bean.

- Si tengo varios Beans que devuelven un mismo tipo (por ejemplo, List<Item>), tengo que usar Primary en un bean o Qualifier debajo del autowired (para que Spring sepa cual ineyctar. Otra manera es ponerle de nombre "default" al Qualifier, y el mismo nombre al bean que quiera por defecto.

- Por qué aparece getImporte() en el JSON aunque no lo agregaste manualmente?
Porque Jackson, por defecto, convierte tu objeto Java a JSON siguiendo esta regla:

   --Todos los métodos public cuyo nombre empieza con get y que no toman parámetros
   --Se consideran propiedades del objeto, y se serializan automáticamente

-Esta bien que getImporte este en el modelo y no en el servicio porque: 
getImporte() es una lógica de dominio simple, que:

Depende solo del estado interno del objeto

No accede a recursos externos

Representa una propiedad propia del objeto (como decir "el subtotal del ítem")

- @PostConstruct: anotación para un método que se ejecutara después de que las dependencias hayan sido creadas e ineyctadas; por eso, si se realizan acciones con ellas desde el constructor, pueden dar null

public Invoice() {
        System.out.println("Creando el componente de la factura");
    } // en este punto las dependencias aún NO fueron inyectadas

    @PostConstruct
    public void init() {
        System.out.println("Creando el componente de la factura");
        client.setName(client.getName().concat("|"));
        description = description.concat("del cliente: ").concat(client.getName()).concat(" ")
                .concat(client.getLastname());
    } // se ejecuta luego de que el bean fue creado e inyectado completamente

- @PreDestroy: se ejecuta antes de destruir el bean
@PreDestroy
    public void destroy() {
        System.out.println("Destruyendo el componente o bean invoice!");
    } 

- Cuando usás @RequestScope o @SessionScope sobre un componente en Spring, Spring genera un proxy automáticamente. Este proxy representa al bean real, cuya instancia será creada y gestionada por cada request o sesión, según corresponda.
Esto es necesario porque:

Los beans de tipo request o session no existen fuera de su contexto (petición/sesión)

Pero vos podrías querer inyectarlos en un bean singleton, que existe todo el tiempo

Entonces... ¡Spring necesita una capa intermedia (proxy) que resuelva dinámicamente el bean correcto en el momento justo!

- Si la factura es ResquestScope y el cliente Singleton, Spring inyecta un proxy de factura en cliente, para que pueda mantener el estado por cada cliente.
Exiten algunso atributos residuales del proxy que hay que ignorar porque si no da error, en factura junto con @ResquestScope poner:
@JsonIgnoreProperties({"targetSource", "advisors"})

- Guarda porque como cliente es de tipo singleton, cada vez que hagamos una request, si factura genera alguna accion sobre cliente, esta se repetirá y sumara con cada petición (por ejemplo, generando palabras que se repetiran en un string). Esto ocurre también si cliente fue de tipo session, se da cuando en la petición ocurre que un compoenente es de un contexto menor a otro. Entonces cambiamos ambos a ResquestScope para que tengan el mismo contexto.

Entonces: ¿por qué @RequestScope acá?
Para que:
--Se cree una nueva factura (Invoice) para cada request
--El cliente (Client) asociado a esa factura no se comparta entre usuarios
--Evitar modificaciones no deseadas o "efectos colaterales" entre usuarios
Regla práctica
Usá @RequestScope cuando:
--Mutás datos del bean en cada request
--No querés que esos datos se compartan entre solicitudes
--Trabajás con datos "de contexto" (cliente actual, sesión, preferencias)

-@ApplicationScope: contexto en el que varias aplicaciones dentro de Springboot (por ejemplo, tomcat externo) pueden compartir objetos. En Singleton ocurre todo dentro de la misma aplicación.

-Otra forma de solucionar el problema del error por el proxy que genera atributos basura (ocurre también cuando son ambos RequestScope pero no se usa el JsonIgnoreProperties) es crear un objeto real y devolver ese objeto con los datos del objeto proxy:

@GetMapping("/show")
    public Invoice show() {
        Invoice i = new Invoice();
        Client c = new Client();
        c.setLastname(invoice.getClient().getLastname());
        c.setName(invoice.getClient().getName());
        i.setClient(c);
        i.setDescription(invoice.getDescription());
        i.setItems(invoice.getItems());

        return i;
    }

-Tambien se puede usar DTOs

-Hay otro contexto @PrototypeScope que se usa mas en aplicaciones de escritorio o standalone, pero no tanto en apis y REST, que genera una nueva instancia al inyectar y no una referencia compartida por todos los clientes (similar a Request y Session, que serian una especie de prototype también, pero en ámbito web)

- @RestControllerAdvice: los métodos en vez de estar mapeados a una ruta URL, estan mapeados al lanzamiento de una excepción. Se lanza una excepción en algún controlador? Automáticamente se llama al método bajo esta anotación que este mapeado a esa excepción

- ResponseEntity<>: una entidad que va en el cuerpo de una respuesta. En los genéricos va a el contenido que va a tener, puede ser un Map, String, en nuestro caso Error, pero puede ser tambien un ? si no sabemos que va a tener.

- @ExceptionHandler: se especifica la excepción que se va a manejar en el metodo

 @ExceptionHandler({ ArithmeticException.class })
    public ResponseEntity<?> divisionByZero(Exception ex) {

        return ResponseEntity.internalServerError().body("error 500");
    }
Pero ahora vamos a devolver en vez del String, el objeto dto del Error que creamos:

@ExceptionHandler({ ArithmeticException.class })
    public ResponseEntity<?> divisionByZero(Exception ex) {
        Error error = new Error();
        error.setDate(new Date());
        error.setError("Error división por cero!");
        error.setMessage(ex.getMessage());
        error.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());

        return ResponseEntity.internalServerError().body(error);
        // return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR.value()).body(error);
    }

-En caso de que Spring lance la excepción por defecto en vez de la personalizada al no encontrar un recurso, poner esta linea en appication.properties:
spring.mvc.throw-exception-if-no-handler-found=true
y esta también:
spring.web.resources.add-mappings=false
Aparentemente en versiones mas nuevas de Spring esto no ocurre porque el error que se encuentra no es NoHanndlerFound, sino una especialización para resursos estáticos: NoResourceFound

- Otra forma de armar el handler de error: 
 @ExceptionHandler(NumberFormatException.class)
 @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Map<String, String> numberFormatException(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("date", new Date().toString());
        error.put("error", "Número inválido o incorrecto, no tiene formato de dígito!");
        error.put("message", ex.getMessage());
        error.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value() + ""); 
        //la concatenacion es para convertir el objeto a string
	//o poner el valor de tipo Object en la definición del Map

- No usar == para la comparación de objetos porque se compara por referencia, no por valores
  Long es una clase objeto, no un tipo primitivo (long)
  La pregunta es: ¿Apuntan a la misma ubicación en memoria?
  Y no: ¿Tienen el mismo valor?
  La forma correcta de comparar es con el método equals()

 @Override
    public User findById(Long id) {
        User user = null;
        for (User u : users) {
            if (u.getId().equals(id)) {
                user = u;
                break;
            }
        }
    }

    }


- UserNotFoundException: es convención el sufijo Exception cuando se crean excepciones personalizadas. Tienen que extender de la clase Exception o RuntimeException. Esta ultima no obliga a usar try-catch

- En la carpeta exceptions se definen las excepciones personalizadas, que extienden de RuntimeException. Luego, en la clase ExceptionHandlerController (anotada con @RestControllerAdvice), se crean los métodos con @ExceptionHandler encargados de capturar esas excepciones y responder con una estructura de error personalizada, normalmente en formato JSON.


- // @GetMapping("/show/{id}")
    // public User show(@PathVariable(name = "id") Long id) {

    // return service.findById(id);
    // }
    // devuelve 200 si es nulo

    @GetMapping("/show/{id}")
    public User show(@PathVariable(name = "id") Long id) {
        User user = service.findById(id);
        if (user == null) {
            throw new UserNotFoundException("Error el usuario no existe!");
        }
        System.out.println(user.getLastname());
        return user;
    }

Cuando usamos un Optional:

 @GetMapping("/show/{id}")
    public User show(@PathVariable(name = "id") Long id) {
        User user = service.findById(id).orElseThrow(() -> new UserNotFoundException("Error el usuario no existe!"));
        System.out.println(user.getLastname());
        return user;
    }

Otra forma: 
 @GetMapping("/show/{id}")
     public ResponseEntity<?> show(@PathVariable(name = "id") Long id) {
     Optional<User> optionalUser = service.findById(id);
     if (optionalUser.isEmpty()) {
     return ResponseEntity.notFound().build();
     }

     return ResponseEntity.ok(optionalUser.orElseThrow());
     }
     otra forma, devuelve 404

Con Optional, método en el service:
 public Optional<User> findById(Long id) {
        User user = null;
        for (User u : users) {
            if (u.getId().equals(id)) {
                user = u;
                break;
            }
        }
        // no usar == para la comparación porque compara por referencia, no por valores
        // Long es una clase objeto, no un tipo primitivo (long)
        // la pregunta que hace == es: ¿Apuntan a la misma ubicación en memoria?
        // y no: ¿Tienen el mismo valor? para eso esta equals()
        return Optional.ofNullable(user); // si no encuentra el usuario, devuelve un Optional.empty() (en vez de null)

Mas compacto, con flujo:
@Override
    public Optional<User> findById(Long id) {
        return users.stream().filter(u -> u.getId().equals(id)).findFirst();
    }

Mas allá de que capture el error o no, en el primer método estoy devolviendo simplemente un null, por eso la respuesta tiene status 200; pero en el segundo, estoy tratando de acceder en el sout a un atributo de algo que es null, que no existe, por eso ahi sí tira error NPE.

-El profe dice que es mejor asociar excepciones al controlador y no al service, pero hay otros que prefieren al reves, y ambas formas son correctas. ChatGPT valida al profe:

El servicio (@Service) representa la lógica de negocio pura: trabaja con datos, reglas, validaciones internas...
No debería saber ni preocuparse por:
--Qué tipo de status HTTP devolver
--Qué tipo de error mostrar al usuario final
Ese rol le corresponde al controlador (@RestController).
¿Qué pasaría si lanza la excepción directamente el service?
Posibles problemas:
--El servicio estaría acoplado a la capa web (sabrá que existe un UserNotFoundException)
--Lo hace menos reutilizable si mañana querés usarlo en otra app (por ejemplo, consola o escritorio)
--Te limita si querés aplicar otras políticas de manejo de errores por capa
Pero hay excepciones
Si la excepción es 100% lógica de negocio, como por ejemplo:
--SaldoInsuficienteException
--StockNoDisponibleException
En esos casos sí está bien que la lance el service, porque representa una regla de negocio rota, no una falla técnica o HTTP.

- Un interceptor es un fragmento de código reutilizable que intercepta un método del controlador para agregar funcionalidad antes o después. Implementan la interfaz HandlerInterceptor. Define tres métodos default o con implementación por defecto (prehandle, posthandle, aftercompletion), lo cual permite que las clases que la implementen no estén obligadas a sobrescribir esos métodos, salvo que necesiten hacerlo.

En la clase de configuracion en la raiz:
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Autowired
    @Qualifier("timeInterceptor")
    private HandlerInterceptor timeInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(timeInterceptor);
    }

} 
De esta forma: "registry.addInterceptor(timeInterceptor);", el interceptor se aplica a todas las rutas, pero si queremos que se aplique solo a algunas, encadenamos el metodo addPathPatterns, o excludePathPatterns para excluir
registry.addInterceptor(timeInterceptor).addPathPatterns("/app/**"); 
Los asteriscos indican todas las rutas a partir de la ruta base precedente.

- Si queremos personalizar el mensaje según el método del controlador que se está ejecutando, casteamos el handler de tipo Object a HandLerMethod y llamamos a los métodos reflexivos. También agregamos tiempo transcurrido:

@SuppressWarnings("null")
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        HandlerMethod controller = (HandlerMethod) handler;
        logger.info("LoadingTimeInterceptor: preHandle() entrando ...." + controller.getMethod().getName());
        return true;
    }
Alternativa mas directa:
..."LoadingTimeInterceptor: postHandle() saliendo ...." + ((HandlerMethod) handler).getMethod().getName());...


@SuppressWarnings("null")
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        HandlerMethod controller = (HandlerMethod) handler;
        logger.info("LoadingTimeInterceptor: preHandle() entrando ...." + controller.getMethod().getName());

        long start = System.currentTimeMillis();
        request.setAttribute("start", start);

        Random random = new Random();
        int delay = random.nextInt(500);
        Thread.sleep(delay); // para simular un retraso despues de la petición
        return true;
    }

    @SuppressWarnings("null")
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
        long end = System.currentTimeMillis();
        long start = (Long) request.getAttribute("start");
        long result = end - start;

        logger.info("Tiempo transcurrido: " + result + " milsegundos!");
        logger.info(
                "LoadingTimeInterceptor: postHandle() saliendo ...." + ((HandlerMethod) handler).getMethod().getName());

    }

Cuando retorno false en el preHandle, corto con el stack de interceptores y con la respuesta del controaldor. Puedo armar una respuesta en ese mismo preHandle para devolver:

@SuppressWarnings("null")
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        HandlerMethod controller = (HandlerMethod) handler;
        logger.info("LoadingTimeInterceptor: preHandle() entrando ...." + controller.getMethod().getName());

        long start = System.currentTimeMillis();
        request.setAttribute("start", start);

        Random random = new Random();
        int delay = random.nextInt(500);
        Thread.sleep(delay); // para simular un retraso despues de la petición

        Map<String, String> json = new HashMap<>();
        json.put("error", "no tienes acceso a esta página!");
        json.put("date", new Date().toString());

        ObjectMapper mapper = new ObjectMapper();
        String jsonString = mapper.writeValueAsString(json);
        response.setContentType("application/json");
        response.setStatus(401);
        response.getWriter().write(jsonString);
        return false;
        // return true;
    }

El atributo request viene del preHandle():

 @GetMapping("/foo")
    public ResponseEntity<?> foo(HttpServletRequest request) {
        Map<String, Object> data = new HashMap<>();
        data.put("title", "Bienvenidos al sistema de atención!");
        data.put("date", new Date());
        data.put("message", request.getAttribute("message"));
        return ResponseEntity.ok(data);
    }

Asi estoy manejando as horas:
Calendar calendar = Calendar.getInstance();
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        System.out.println(hour);

        if (hour >= open && hour < close) {
            StringBuilder message = new StringBuilder("Bienvenidos al horario de atención a clientes");
            message.append(", atendemos desde las ");
            message.append(open);
            message.append(" h");
            message.append(" hasta las ");
            message.append(close);
            message.append(" h.");
            message.append("Gracias por su visita!");
            request.setAttribute("message", message.toString());
            return true;
        }   
Si tengo que usar minutos también, como 21:30, puedo poner poner la hora con decimal en el application.properties (21.5 para 21:30) y que el atributo enj el interceptor sea de tipo double, en vez de int. O puedo configurar horas y minutos y usar la clase LocalTime:
properties:
config.calendar.open.hour=14
config.calendar.open.minute=0
config.calendar.close.hour=21
config.calendar.close.minute=30

clase:
LocalTime now = LocalTime.now();
LocalTime openTime = LocalTime.of(openHour, openMinute);
LocalTime closeTime = LocalTime.of(closeHour, closeMinute);

if (!now.isBefore(openTime) && now.isBefore(closeTime)) {
    // Está dentro del horario
}

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm");
message.append(openTime.format(formatter));
message.append(" h hasta las ");
message.append(closeTime.format(formatter));
message.append(" h.");

-Programación Orientada a Aspectos: paradigma de programación que permite una mejor separación de preocupaciones transversales (cross-cutting concerns) en el código. En lugar de modularizar el código basado en funcionalidades específicas (como en la programación orientada a objetos), la POA se enfoca en separar el código que afecta a múltiples partes del sistema y que no esta relacionado directamente con la lógica de negocio, como la seguridad, el registro de eventos, la autenticación o el manejo de transacciones. Se evita la repetición y acoplamiento del código. Es similar al uso de interceptores, nada más que no se circunscribe solamente a resquests.
--Join point (punto de cruce o unión): representa la invocación de un método o manejo de excepciones
--Advice: método que se ejecuta cerca de la ejecución del join point (antes, después, alrededor).
--Pointcuts: agrupación de uno o mas join points que indican donde se aplicara el advice, suele estar definido por expresiones regulares (ejemplo, que los advices se ejecuten en determinado package, en joint points que contengan la palabra service)

-Para que funcione AOP hay que agregar una dependencia al pom:
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-aop</artifactId>
			</dependency>
Y agregar la anotación: @EnableAspectJAutoProxy en la clase principal (en las ultimas versiones de Spring puede que no sea necesario).

-Ejemplo de advice before en un join point:

@Aspect
@Component
public class GreetingAspect {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Before("execution(String com.santi.curso.springboot.app.aop.springboot_aop.services.GreetingService.sayHello(..))")
    public void loggerBefore(JoinPoint joinPoint) {

        String method = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        logger.info("Antes: " + method + " con los argumentos " + args);
    }
}

"execution(String com.santi.curso.springboot.app.aop.springboot_aop.services.GreetingService.sayHello(..))" se peude poner un "*" en vez de String para que funcione con todos los tipso de retorno. Aplica también sustituir el método por el *, o la clase, y asi sirve para cualquiera.


- @Before("execution(* com.santi.servicios..*.saludar*(..))")
Esto se traduce como:

“Interceptá todos los métodos cuyo nombre empiece con saludar,
en cualquier clase de cualquier subpaquete dentro de com.santi.servicios,
sin importar qué tipo devuelven ni cuántos parámetros reciben.”

Los dos puntos se usan como comodín múltiple: "Cualquier cosa, de cualquier longitud"
El asterisco se usa como comodín simple: "Cualquier cosa, pero en una sola posición"

Advice con around:
@Around("execution(String com.santi.curso.springboot.app.aop.springboot_aop.services.*.*(..))")
    public Object loggerAround(ProceedingJoinPoint joinPoint) throws Throwable {

        String method = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());

        Object result = null;

        try {
            logger.info("El método " + method + "() con los parámetros: " + args);
            result = joinPoint.proceed();
            logger.info("El método " + method + "() retorna el resultado: " + args);
            return result;
        } catch (Throwable e) {
            logger.error("Error en la llamada del método: " + method + "()");
            throw e;
        }

-@Order(//numero): para establecer orden de clases de aspectos (ordena por tipo de punto de corte, pero tener en cuenta que un aspecto con mas prioridad es el primero en entrar y el ULTIMO en salir)

-@Pointcut: para reutilizar un punto de corte
	@Pointcut("execution(String com.santi.curso.springboot.app.aop.springboot_aop.services.GreetingService.*(..))")
    		public void greetingLoggerPointcut() {}

   	@Before("greetingLoggerPointcut()")...

-Se pueden agrupar también en una clase aparte, y luego en la anotación de los advices de los aspectos se especifica la clase con el método (si están en el mismo package)

- Hibernate es un framework de ORM. JPA es un estándar de persistencia, una API que contiene los contratos que debe implementar un proveedor, siendo Hibernate uno de ellos. Entonces Hibernate es una especificación para la API de persistencia de Java. Trabaja con objetos que están mapeados a tablas SQL, crea una base de datos orientada a objetos virtual, sobre la base de datos relacional.

- Las tablas se relacionan mediante llaves foráneas; en los objetos mapeados es mediante atributos, relaciones entre ellos y la anotación que corresponde a esa relación (manytoone, onetomany, etc.).

-Spring Data JPA integra Hibernate a Spring.

-Para las consultas en Spring Data JPA se puede hacer mediante el nombre del método con palabras clave o con la definición de la consulta HQL o JPQL en una anotacion @Query. Tambien se puede con SQL nativo.

-Entity: clase POJO que esta mapeada a uan tabla de BDD.

-Se implementa CommandLineRunner para…
--Ejecutar lógica justo después de que Spring arranca
--Acceder a beans ya inicializados
--Inyectar datos o probar funcionalidades iniciales

void run(String... args) throws Exception;
Cuando se implementa esta interfaz en la clase (generalmente en la clase principal con @SpringBootApplication), Spring ejecuta ese método una vez al arrancar la aplicación.

Y los argumentos args?
Son los argumentos pasados por línea de comandos al ejecutar el programa. Por ejemplo:
java -jar miapp.jar arg1 arg2

-Si no hay un @RestController, ni endpoints web, ni configuración para mantener el contexto vivo (como un servidor web embebido), la aplicación se apaga al terminar run(). Estaríamos "ejecutando" el servidor, en vez de "levantándolo".

-@Entity
@Table(name = "persons") // por defecto se usa el nombre de la clase
public class Person {

}

-Lo mismo pasa con los atributos, si se llaman igual que en la tabla no hace falta explicitar. Salvo que sean palabras compuestas, porque en BDD por convención se separa con guion bajo, no con camelCase:
@Column(name = "programming_language")

    private String programmingLanguage;

-En una clase Entity, si tenemos un cosntructor personalizado con parámetros, estamos obligados siempre a explicitar un constructor vacio.

-Anotaciones para la clave primaria:
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

GeneratedValue indica como se va a crear la llave. Para MySQL y SQLServer se suele usar IDENTITY, que es autoincremental (también en Postgre); SEQUENCE se usa mucho en Postgre y Oracle (implica crear una secuencia en la tabla para generar los IDs); AUTO para detectar de forma automática, pero no siempre funciona bien

-En Jpa, las interfaces de repositorio que uno crea pueden heredar de otros repositorios como CrudRepository o JpaRepository. La clase no lleva anotacion, ya viene implicita al extender.

-Configuraion de Jpa en application.properties:
spring.application.name=springboot-jpa
spring.datasource.url=jdbc:mysql://localhost:3306/db_springboot
spring.datasource.username=root
spring.datasource.password=12345678
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
spring.jpa.show-sql=true   //ver el log de las consultas en la terminal
spring.jpa.hibernate.ddl-auto=create       //para que se creen las tablas automaticamente a partir de los entities, pero solo para desarrollo, no producción; cada vez que levantamos el servidor, elimina todas las tablas con el mismo nombre que las entities antes de crearlas; Hibernate tambien puebla las filas si hay algun archivo import.sql en resources

spring.jpa.hibernate.ddl-auto=update //asi solo se producen cambios si se cambia el esquema en entity, pero no se ejecuta el import.sql; ojo que tambien puede llegar a ser contraproducente en ambientes de produccion

-Sin toString() personalizado en la calse Entity, se mostraría algo así al imprimir el objeto:
com.tuapp.models.Person@3fa77460
O sea, solo muestra el nombre de la clase + el hash del objeto.

- Cuando se hace sobrecarga de métodos, los métodos no pueden tener la misma firma (misma cantidad de argumentos del mismo tipo).

public void findOne() {
		// Person person = personRepository.findById(1L).orElseThrow();
		// System.out.println(person);

		// Person person = null;
		// Optional<Person> optionalPerson = personRepository.findById(1L);
		// if (optionalPerson.isPresent()) {
		// person = optionalPerson.get();
		// }
		// System.out.println(person);

		// personRepository.findById(1L).ifPresent(person ->
		// System.out.println(person));
		personRepository.findById(1L).ifPresent(System.out::println);
	}

Forma	           ¿Lanza excepción si no hay valor?	         Concisa	Segura
orElseThrow()	                  Sí	                           Sí	         Solo si estás seguro
isPresent() + get()	          No	                           No	         Sí
ifPresent(x -> ...)	          No	                           Sí	         Sí
ifPresent(System.out::println)	  No	                           Muy	         Sí

:: se llama method reference, y es equivalente, en el ejemplo, a: x -> System.out.println(x)


-@Transactional: protege cuando varias operaciones sobre la base (INSERT, UPDATE, DELETE) se ejecutan juntas, que si algo falla en el medio, todo se revierta, y que no quede la base en un estado inconsistente. Todo lo que ocurra dentro de este método se ejecuta dentro de una transacción.
Si algo falla (una excepción), se hace rollback automáticamente y no se guardan los cambios. Se suele usar en métodos en servicios (@Service). (improtarlo de org.springframework...)
Para operaciones de solo lectura se escribe @Transactional(readOnly = True).


-Para pedir datos por consola y luego guardarlos (create):
		Scanner scanner = new Scanner(System.in);
		String name = scanner.next();
		String lastname = scanner.next();
		String programmingLanguage = scanner.next();
		scanner.close();

		Person person = new Person(null, name, lastname, programmingLanguage);

		Person personNew = personRepository.save(person);
		System.out.println(personNew);

-Para modificar datos (update: buscar el objeto, modificarlo, y como queda en el contexto de persistencia, hibernate hace un update en vez de un insert):
		if (optionalPerson.isPresent()) {
			Person person = optionalPerson.get();
			System.out.println(person);
			System.out.println("Ingrese el lenguaje de programación:");
			String programmingLanguage = scanner.next();
			person.setProgrammingLanguage(programmingLanguage);
			Person personDb = personRepository.save(person);
			System.out.println(personDb);
		} else {
			System.out.println("No se encontró la persona con id: " + id);
		}

- Para eliminar tenemos deleteById y delete. En el segundo, el objeto tiene que estar en el contexto de persistencia (trayendolo antes con una consulta).

-Funcion concatenar en las queries: 
    @Query("select concat(p.name, ' ', p.lastname) as fullname from Person p where p.id=?1")
    String getFullNameById(Long id);


-En JPA se obtiene directamente el registro (o los campos) como un arreglo de objetos, pero en la integración de Spring con JPA se obtiene el objeto y luego se hace el cast a arreglo de objetos 

PersonRepository:
    		// @Query("select p.id, p.name, p.lastname, p.programmingLanguage from Person p
    		// where p.id=?1")
    		// Object obtenerPersonDataById(Long id);
    		@Query("select p.id, p.name, p.lastname, p.programmingLanguage from Person p where p.id=?1")
    		Optional<Object> obtenerPersonDataById(Long id);

SpringbootJpaApplication:
		System.out.println("============== consulta por campos personalizados por el id ==============");
		// Object[] personReg = (Object[]) personRepository.obtenerPersonDataById(id);
		// System.out.println("id=" + personReg[0] + ", nombre=" + personReg[1] + ",
		// apellido=" + personReg[2]
		// + ", lenguaje=" + personReg[3]);
		Optional<Object> optionalReg = personRepository.obtenerPersonDataById(id);
		if (optionalReg.isPresent()) {
			Object[] personReg = (Object[]) optionalReg.get();
			System.out.println("id=" + personReg[0] + ", nombre=" + personReg[1] + ", apellido=" + personReg[2]
					+ ", lenguaje=" + personReg[3]);
		}


-En @Query: 

--"select new ..." se usa cuando no se quiere traer todos los campos, por ejemplo para optimizar rendimiento. Se está indicando explícitamente que se quiere crear instancias de una clase usando un constructor que reciba esos campos específicos. Tiene que exister el constructor en la clase con esa firma.

--También se puede hacer "select new com.tuapp.dto.PersonDTO(...)" si se quiere devolver un DTO en vez de la entidad.


- Cuando usamos el operador new y creamos una instancia de un DTO, como la manejamos nosotros y no JPA ni ningun framework, no hace falta tener un constructor vacio.

-La clase Dto no es una clase que se encuentre dentro del contexto de persistencia, como una calse Entity, por lo cual se debe indicar el nombre de la clase completa en la query, es decir, con su package.

-El @PrePersist en JPA cumple un rol muy parecido a los interceptores o aspectos (@Before, preHandle, etc.), solo que en el contexto del ciclo de vida de las entidades, no de controladores o métodos.

  @PreUpdate
    public void preUpdate() {
        System.out.println("evento del ciclo de vida del entity pre-update");
        this.updatedAt = LocalDateTime.now();
    }


-Un cliente tiene muchas facturas. En Invoice tenemos:

@ManyToOne
private Client client;

Invoice tendrá la clave foránea de Client


-Es normal que la primera vez que ejecutemos el servidor con spring.jpa.hibernate.ddl-auto=create dé un error si Hibernate intenta eliminar una tabla o clave foránea que todavía no fue creada. Recordar que, en bases de datos relacionales, antes de eliminar una tabla que está referenciada por claves foráneas desde otras tablas, deben eliminarse primero esas claves foráneas. Esto evita violaciones de integridad referencial y previene que la base de datos quede en un estado inconsistente.

-@JoinColumn(name="id_cliente")
 @ManyToOne
 private Client client;

JoinColumn establece o crea el campo que se usara como clave foránea. Guarda si se cambia cuando ya existe un campo con otro nombre de clave foránea por que puede dar error (con el create del hibernate-ddl por ejemplo, porque va a buscar un campo con un nombre que todavía no existe para eliminar la clave foranea).

-Desde la clase Cliente (recordar que en las anotaciones de relaciones entre entidades, la primera palabra se refiere siempre a la clase donde nos encontramos):

@OneToMany(cascade = { CascadeType.ALL }, orphanRemoval=true)
private List<Address> addresses = new ArrayList<>;

Significado de cascade:
Cuando se realice una acción (como persistir, actualizar o eliminar) sobre un objeto Cliente, esa acción también se propagará automáticamente a todos los elementos de la lista addresses. Así se asegura que las entidades relacionadas (Address) se manejen en conjunto con Cliente sin necesidad de tratarlas manualmente una por una.

orphanRemoval = true: automáticamente Hibernate genera un DELETE en la base de datos para eliminar esa dirección que se sacó de la lista.
Si no tuviera orphanRemoval, la dirección seguiría existiendo en la base aunque ya no esté asociada a ningún cliente (quedaría "huérfana"); así se mantiene más limpia la base.

CascadeType.REMOVE: sirve para eliminar en cascada cuando el padre es borrado.

orphanRemoval = true: sirve para eliminar cuando quitás un hijo del vínculo, sin necesidad de borrar el padre.

No olvidarse de inicializar la lista (o colección) en estas relaciones (con el new).
Tambien se puede inicializar en el constructor vacio, y ver que los otros constructores lo llamen:

    @OneToMany(cascade = { CascadeType.ALL }, orphanRemoval = true)
    private List<Address> addresses;

    public Client() {
        addresses = new ArrayList<>();
    }

    public Client(String name, String lastname) {
        this();
        this.name = name;
        this.lastname = lastname;
    }

-La tabla dueña (o propietaria) es la que tiene la clave foránea (FOREIGN KEY) que define la relación. Casi siempre será la "hija" en una relación 1:N (uno a muchos) o N:1 (muchos a uno), porque la "hija" necesita saber quién es su "padre". (Ejemplo: una factura necesita saber a qué cliente pertenece.).


-mappedBy se usa en la entidad que NO es la dueña de la relación. El valor de mappedBy es el nombre del atributo en la otra clase que sí es el dueño. ¿Qué pasa sin mappedBy? Hibernate puede generar relaciones o tablas intermedias extra, pero no se "ensucia" una de las tablas de la relación con claves foráneas; queda desacoplada, limpia:

@Entity
public class Cliente {
    
    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL)
    private List<Factura> facturas;
}

@Entity
public class Factura {

    @ManyToOne
    @JoinColumn(name = "cliente_id")
    private Cliente cliente;  // <-- Este es el atributo al que "mappedBy" hace referencia
}


-Como tenemos la relación en cascada (el all incluye el persist), cuando creemos el cliente, automáticamente se crearan las direcciones, por lo tanto no hace falta guardar las direcciones primero (este es un ejemplo de beneficio de usar un framework, nos automatiza tareas):	

		Client client = new Client("Fran", "Moras");

		Address address1 = new Address("El vergel", 1234);
		Address address2 = new Address("Vasco de Gama", 9875);

		client.getAddresses().add(address1);
		client.getAddresses().add(address2);

		clientRepository.save(client);



-Problema de lazy fetching:

		@Transactional
		public void oneToManyFindById() {

			Optional<Client> optionalClient = clientRepository.findById(2L);
			optionalClient.ifPresent(client -> {

			Address address1 = new Address("El vergel", 1234);
			Address address2 = new Address("Vasco de Gama", 9875);
	
			client.getAddresses().add(address1);
			client.getAddresses().add(address2);
	
			clientRepository.save(client);
	
			System.out.println(client);

			});
		}

En una relación @OneToMany, la carga es LAZY por defecto (no carga la lista de direcciones automáticamente cuando buscás el cliente). Cuando se intenta acceder a esa lista (getAddresses()), Hibernate trata de cargar las direcciones recién ahí, pero ya se salió de la sesión de Hibernate (porque findById solo abre/cierra la sesión internamente). LazyInitializationException
En vez de hacer un get, hacer un set: client.setAddresses(Arrays.asList(address1, address2)); Hibernate simplemente pisa el campo addresses en el objeto Java con tu nueva lista. No necesita consultar nada a la base.

-En la version de Spring 3.4.5 y como estamos trabajando directamente con commandlinerunner, va a mostrar los ids de los addresses como null (cambiando a la 3.1.5, sí lo haria). Porque en proyectos reales grandes (con miles de entidades), actualizar todos los objetos en memoria apenas se hace save sería un gasto enorme en rendimiento. Por eso, ahora solo actualiza automáticamente el ID del objeto raíz (Client), pero no los IDs de las entidades nuevas de las colecciones.

Qué pasaría si organizás tu código bien en Service + Repository?
Crearías un @Service separado (por ejemplo ClientService).
Ahí el método @Transactional sí sería interceptado por el proxy de Spring.
Entonces:
Se abre una sesión real de Hibernate.
Se maneja bien el ciclo de vida de las entidades.
El flush() sería respetado como corresponde.
El refresh() (de EntityManager) Gpodría usarse.
Y los IDs en el objeto refrescado aparecerían bien.

-Poner spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true en application.properties. Permite que Hibernate cargue colecciones o atributos LAZY aunque no estés dentro de una transacción activa. Si bien esto se considera un antipatron y no es recomendable en aplicaciones web, como estamos en consola y en modo desarrollador no hay problema. 
Como alternativa se puede agregar la propiedad fetch = FetchType.EAGER en la anotación @OneToMany.

-Para no usar estos trucos, se puede crear una consulta personalizada en el repositorio (asi no necesita usar el proxy, ni la carga perezosa, ni el eager haciendo muchas consultas):
	@Query("select c from Client c join fetch c.addresses where c.id = ?1")
        Optional<Client> findOne(Long id);



-Uso de @JoinTable para personalizar tabla intermedia:

    @OneToMany(cascade = { CascadeType.ALL }, orphanRemoval = true)
    // @JoinColumn(name = "client_id")
    @JoinTable(name = "tbl_clientes_to_direcciones", joinColumns = @JoinColumn(name = "id_cliente"), inverseJoinColumns = @JoinColumn(name = 				"id_direccion"), uniqueConstraints = @UniqueConstraint(columnNames = {"id_direccion" }))
    private List<Address> addresses;


-Explicación de ChatGPT e claves foráneas, tablas itnermedias y entidades dueñas:
¿Por qué Hibernate asocia joinColumns a la tabla Client, si en otros casos (sin tabla intermedia) la tabla Address sería la que tiene la FK?
La respuesta es:
1. Porque la anotación está en el Client
Vos estás parado en la clase Client.
Ahí declaraste @OneToMany(...) private List<Address> addresses;.
Como no hay mappedBy, Hibernate interpreta que Client es la entidad dueña de la relación (propietario en JPA).
Por contrato de JPA:
"La entidad que declara la relación (sin mappedBy) es la que define el mapeo físico de la relación."
Entonces, el joinColumns que estás escribiendo se entiende que referencia a la tabla asociada a Client.
2. Porque @JoinTable cambia las reglas normales
Cuando hay tabla intermedia, ya no es como el modelo directo (sin tabla intermedia):
Sin tabla intermedia: La tabla hija (addresses) tiene una FK hacia el padre (client).	
Con tabla intermedia: La tabla intermedia (tbl_clientes_to_direcciones) tiene dos FK: una hacia client, otra hacia address.
Entonces:
Ya no se agrega client_id en la tabla addresses.
Hibernate necesita saber dónde está el client_id.
Y eso se lo decís explícitamente vos con joinColumns.
Pero ¿qué tabla referencia joinColumns?
Siempre referencia al ID de la entidad donde está declarada la relación.
¿Qué ID?
El de Client.
Porque estás escribiendo el @JoinTable en Client.
Un mini resumen con tus palabras
Sin tabla intermedia: el hijo (ej: addresses) lleva la FK.
Con tabla intermedia: la tabla intermedia lleva dos FK, y la relación es administrada desde el lado que anotaste.
Hibernate "sabe" que joinColumns apunta al ID de Client porque estás escribiendo todo esto dentro de la clase Client.
(No lo deduce mágicamente de la base de datos, lo deduce de la ubicación de la anotación en el código).

-El remove no va a funcionar porque la referencia del objeto, cuando se persiste con JPA, cambia. Son dos instancias distntas, apuntan a espacios de memoria diferentes. Para solucionarlo, hay que implementar el equals (con source action) en la clase Address, para cambiar el criterio de comparación por valor del id en vez de por referencia:

	@Transactional
	public void removeAddress() {
	
		Client client = new Client("Fran", "Moras");

		Address address1 = new Address("El vergel", 1234);
		Address address2 = new Address("Vasco de Gama", 9875);

		client.getAddresses().add(address1);
		client.getAddresses().add(address2);

		clientRepository.save(client);

		System.out.println(client);

		Optional<Client> optionalClient = clientRepository.findById(3L);
		optionalClient.ifPresent(c -> {
			c.getAddresses().remove(address1);
			clientRepository.save(c);
			System.out.println(c);
		});

	}

-Para el delete con relaciones existenes anda asi:
	@Transactional
	public void removeAddressFindById() {

		Optional<Client> optionalClient = clientRepository.findById(2L);
		optionalClient.ifPresent(client -> {

			Address address1 = new Address("El vergel", 1234);
			Address address2 = new Address("Vasco de Gama", 9875);

			client.setAddresses(Arrays.asList(address1, address2));

			clientRepository.save(client);

			System.out.println(client);

			Optional<Client> optionalClient2 = clientRepository.findById(2L);
			optionalClient2.ifPresent(c -> {
				Address addressToRemove = c.getAddresses()
						.stream()
						.filter(a -> "Vasco de Gama".equals(a.getStreet()))
						.findFirst()
						.orElseThrow(() -> new RuntimeException("Address not found"));
				c.getAddresses().remove(addressToRemove);
				clientRepository.save(c);
				System.out.println(c);
			});

		});

	}
Hay que encontrar de nuevo el objeto con filter porque no es el mismo después de la persistencia.


-Nombrar a la otra clase de la relacion en el toString() se hace en una sola de ellas, porque, si no, se genera un loop infinito.


-En una relación @OneToMany NO bidireccional (unidireccional):
Solo una clase (el "padre") tiene la referencia a la colección (List<Address>).
No existe ninguna referencia de vuelta desde el Address hacia el Client.
Usás @JoinColumn en el lado del @OneToMany, sobre la lista.
Hibernate genera una foreign key en la tabla hija (addresses) apuntando al padre (client).

En una relación @OneToMany bidireccional:
El padre (Client) tiene una lista de addresses.
Cada Address tiene una referencia al Client.
El @JoinColumn ahora va en el lado de @ManyToOne (en la clase hija Address).
Y el @OneToMany en el padre usa mappedBy, para indicar que la otra clase (hija) es la que maneja realmente la relación.

-	@Transactional
	public void oneToManyInvoiceBidireccional() {

		Client client = new Client("Fran", "Moras");

		Invoice invoice1 = new Invoice("compras de la casa", 5000L);
		Invoice invoice2 = new Invoice("compras de oficina", 8000L);

		List<Invoice> invoices = new ArrayList<>();
		invoices.add(invoice1);
		invoices.add(invoice2);
		client.setInvoices(invoices);

		invoice1.setClient(client);
		invoice2.setClient(client);

		clientRepository.save(client);

		System.out.println(client);
	}

Guardamos solo el cliente porque al tener activada la opción de cascada en la relación, automáticamente se guardan las facturas también.

Forma optimizada:

	@Transactional
	public void oneToManyInvoiceBidireccional() {

		Client client = new Client("Fran", "Moras");

		Invoice invoice1 = new Invoice("compras de la casa", 5000L);
		Invoice invoice2 = new Invoice("compras de oficina", 8000L);

		client.addInvoice(invoice1).addInvoice(invoice2);

		clientRepository.save(client);

		System.out.println(client);
	}

En Client:

public Client addInvoice(Invoice invoice) {
        invoices.add(invoice);
        invoice.setClient(this);
        return this;
} // tipo de retorno Client para devolver una referencia y poder encadenar métodos

-Para solucionar el error que no soporta mas de dos fetch de colecciones en una consuta, cambiar los list por set.

-Haciendo left join de la clase cliente con las direccioens y las facturas (y los detalles de cliente) en las consultas personalizadas, no tendremos el problema de lazy fetching porque estamos trayendo todos los datos al contexto de persistencia, con esa misma consulta.


-	@Transactional
	public void oneToOneBidireccional() {

		Client client = new Client("Erba", "Pura");

		ClientDetails clientDetails = new ClientDetails(true, 5000);

		client.setClientDetails(clientDetails);
		// clientDetails.setClient(client);
		clientRepository.save(client);

		System.out.println(client);

	}

Se puede optimizar poniendo lo comentado en el setClientDetails de Client:

    public void setClientDetails(ClientDetails clientDetails) {
        this.clientDetails = clientDetails;
        clientDetails.setClient(this);
    }

Similar con el remove, pero cuidado con el orden de las sentencias:
    public void removeClientDetails(ClientDetails clientDetails) {
        clientDetails.setClient(null);
        this.clientDetails = null;
    }


-   @ManyToMany(cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    Set<Course> courses;               

No ponemos CascadeType.ALL porque si eliminamos un alumno, no podemos eliminar el curso también, ya que puede estar siendo ocupado por otros estudiantes al mismo tiempo.


-Este código, en la version 3.4.5 de Spring Boot (pero no en la 3.1.5), me genera dos registros del curso2:

	@Transactional
	public void manyToManyFind() {

		Optional<Student> studentOptional1 = studentRepository.findById(1L);
		Optional<Student> studentOptional2 = studentRepository.findById(2L);

		Student student1 = studentOptional1.get();
		Student student2 = studentOptional2.get();

		Course course1 = new Course("Curso de java master", "Andres");
		Course course2 = new Course("Curso de Spring Boot", "Andres");

		student1.setCourses(Set.of(course1, course2));
		student2.setCourses(Set.of(course2));

		studentRepository.saveAll(List.of(student1, student2));

		System.out.println(student1);
		System.out.println(student2);

	}


Cambió cómo Hibernate maneja entidades nuevas (transient) relacionadas en cascada.
Ya no reconoce automáticamente que un objeto repetido en memoria es el mismo, salvo que esté attached (persistido o identificado).
Cada new Course(...), aunque sea la misma instancia, Hibernate trata de "cascadear" la persistencia dos veces si no ve el ID asignado aún.
Este problema lo documentaron como un cambio deliberado en Hibernate 6.3:
"Hibernate no considera entidades transient como iguales durante persistencia en cascada. Se procesan independientemente."
En Hibernate 6.1 (Spring Boot 3.1.5), Hibernate sí detectaba instancias compartidas y no duplicaba.
En Hibernate 6.3 (Spring Boot 3.4.5), procesa cada objeto nuevo sin deduplicarlo automáticamente.
Soluciones:
Persistir manualmente los Course primero (para darles ID).
O, hacer merge en vez de persist si sabés que podrían ser repetidos.
O, buscar si existen antes de asignarlos (findByName, findBySomething).

Solución:

	@Transactional
	public void manyToManyFind() {
		// Esta version no genera registros duplicados en la version 3.4.5 pero hay que
		// desactivar el cascade
		// 1. Guardás los cursos primero (si no existen todavía)
		Course course1 = new Course("Curso de Java Master", "Andres");
		Course course2 = new Course("Curso de Spring Boot", "Andres");
		courseRepository.saveAll(List.of(course1, course2));

		// 2. Los traés ya attachados
		Course course1Db = courseRepository.findByName("Curso de Java Master").orElseThrow();
		Course course2Db = courseRepository.findByName("Curso de Spring Boot").orElseThrow();

		// 3. Creás estudiantes
		Student student1 = new Student("Jano", "Pura");
		Student student2 = new Student("Erba", "Doe");

		// 4. Asignás cursos reales persistidos
		student1.setCourses(Set.of(course1Db, course2Db));
		student2.setCourses(Set.of(course2Db));

		// 5. Guardás estudiantes
		studentRepository.saveAll(List.of(student1, student2));

		System.out.println(student1);
		System.out.println(student2);
	}



Diferencia en hacer los news de studen y course en el mismo método (no duplica) y traer de la base los studens y ahcer news de courses (duplica):

No duplica: 

Student student1 = new Student(...);
Student student2 = new Student(...);

Course course1 = new Course(...);
Course course2 = new Course(...);

student1.setCourses(Set.of(course1, course2));
student2.setCourses(Set.of(course2));

studentRepository.saveAll(List.of(student1, student2));

Aquí student1, student2, course1, y course2 todos son entidades nuevas (transient) en la misma sesión.
Hibernate hace un persist en cascada de todos juntos, sin conflictos, porque nunca cerraste la sesión, nunca hiciste un findById, nunca tocaste nada "medio gestionado, medio no".
Todo es limpio.
Todo es visto como "nuevas entidades" coordinadas.


Duplica:

Student student1 = studentRepository.findById(1L).get();
Student student2 = studentRepository.findById(2L).get();

Course course1 = new Course(...);
Course course2 = new Course(...);

student1.setCourses(Set.of(course1, course2));
student2.setCourses(Set.of(course2));

studentRepository.saveAll(List.of(student1, student2));


student1 y student2 NO son entidades nuevas (transient).
Son entidades ya existentes en la base que trajiste con findById.
(Ya tienen ID, ya están en la base.)
course1 y course2 SÍ son nuevas (transient).
Cuando hacés saveAll, Hibernate:
Vuelve a mirar student1.
Dice: "uh, tiene cursos nuevos (transient) en la colección."
Persisto course1 y course2 por cascada.
Vuelve a mirar student2.
"¡Tiene otro course2 en la colección!"
Pero Hibernate ya hizo un persist de course2 antes, y course2 sigue siendo transient (porque no fue attachado a la sesión).
Hibernate lo intenta persistir de nuevo, como si fuera otra cosa.
Y ahí se duplica.


Asi también anda (ya tenemos cursos y estudiantes en la base):

	public void manyToManyFind2() {

		Optional<Student> studentOptional1 = studentRepository.findById(1L);
		Optional<Student> studentOptional2 = studentRepository.findById(2L);

		Student student1 = studentOptional1.get();
		Student student2 = studentOptional2.get();

		Course course1 = courseRepository.findById(1L).get();
		Course course2 = courseRepository.findById(2L).get();

		student1.setCourses(Set.of(course1, course2));
		student2.setCourses(Set.of(course2));

		studentRepository.saveAll(List.of(student1, student2));

		System.out.println(student1);
		System.out.println(student2);

	}

-Acordarse de agregar hashcodes (y equals) para que se compare por valor y no por instancia al momento de eliminar.

- public interface ProductRepository extends CrudRepository<Product, Long> {

}

Los métodos básicos como save, findAll ya vienen implementados por CrudRepository. Si quiero agregar métodos personalizados simples, puedo declarar solo la firma en la interfaz (usando query methods o @Query). Si necesito lógica más compleja, creo una interfaz ProductRepositoryCustom, la cual será extendida por ProductRepository, y luego creo una clase ProductRepositoryImpl que implementa esa interfaz personalizada.


-  @GetMapping("/{id}")
    public Product view(@PathVariable Long id) {
        return service.findById(id).orElse(null);
    }

Deberia devolver un ResponseEntity, porque peude ser que no se encuentra el producto y entonces debe devolver un mensaje de error.

-Ejemplo de ventaja de Spring: con @RequestBody en lso parámetros, se automatiza la conversion de los datos venidos por json al objeto (gracias a la librería Jackson).

- Si omito un campo en el json, Jackson lo deja en null. Salvo que sea un tipo primitivo, que le pondrá el valor por defecto (0, false). Si envió un campo adicional que no existe, Jackson lo ignora por defecto. Pero se peude cambiar para que de error con al propiedad "@JsonIgnoreProperties(ignoreUnknown = false)" en la clase de la entidad.

- Si el save no detecta un id, hace una creación, sino un update.

-Cuando queresmo devolver algo necesitamos un if, no la expresión lambda del ifpresent.

-Si queremos añadir una dependencia nueva, vamos al comando Spring Initializr: Add Starters, que agrega dependencias al po.xml, como cuando creamos el proyecto (guarda que me agrego la dependencia mal ubicada). O copairlo a mano en el pom.xml. Agregamos el Bean Validation.

-Ponemos @Valid antes de @RequestBody en el controlador. En la clase Entity podemos dejar restriccioens sobre algunos campos como: @NotEmpty, @Size(min = 3, max = 20), @Min(500), @NotNull, @NoBlank.


-En los parametros de rutas post o put, "BindingResult result" tiene que estar justo al lado del objeto que queremos validar (encapsula todos los mensajes de error que se obtienen producto de validaciones no satisfechas). Si existe un error, ahora obtenemos cual o cuales fueron y mandamos los mensajes correspondientes ayudandonos con metodos que capturan la informacion del error (campo, mensaje por defecto).

 @PostMapping
    public ResponseEntity<?> create(@Valid @RequestBody Product product, BindingResult result) {
        if (result.hasFieldErrors()) {
            return validation(result);
        }
        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(product));
    }

 private ResponseEntity<?> validation(BindingResult result) {
        Map<String, String> errors = new HashMap<>();
        result.getFieldErrors().forEach(err -> {
            errors.put(err.getField(), "El campo " + err.getField() + " " + err.getDefaultMessage());
        });
        return ResponseEntity.badRequest().body(errors);
    }

-Mensajes de error personalizados:
--AppConfig:
    @Configuration
    @PropertySource("classpath:messages.properties")
    public class AppConfig {

    }

--messages.properties:
    NotEmpty.product.name=es requerido!
    NotBlank.product.description=es requerido, por favor
    NotNull.product.price=no puede ser nulo, ok!
    Min.product.price=debe ser un valor mayor o igual que 500!

--Product:
    @NotEmpty(message = "{NotEmpty.product.name}")
    @Size(min = 3, max = 20)
    private String name;

    @Min(value = 500, message = "{Min.product.price}")
    @NotNull(message = "{NotNull.product.price}")
    private Integer price;

    @NotBlank(message = "{NotBlank.product.description}")
    private String description;


-Validar de forma mas programática usando clase Validation (en vez de anotaciones):
ProductValidation (en la carpeta raíz). Sacar los @Valid antes de @RequestBody, que sirven para validar por anotaciones, porque si no tendríamos dos validadores ejecutándose al mismo tiempo:

@Component
public class ProductValidation implements Validator {

    @Override
    @SuppressWarnings("null")
    public boolean supports(Class<?> clazz) {
        return Product.class.isAssignableFrom(clazz);
    }

    @Override
    @SuppressWarnings("null")
    public void validate(Object target, Errors errors) {
        Product product = (Product) target;
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", null, "es requerido!");
        // ValidationUtils.rejectIfEmptyOrWhitespace(errors, "description", null,
        // "es requerido, por favor");
        if (product.getDescription() == null || product.getDescription().isBlank()) {
            errors.rejectValue("description", null, "es requerido, por favor");
        }

        if (product.getPrice() == null) {
            errors.rejectValue("price", null, "no puede ser nulo, ok!");
        } else if (product.getPrice() < 500) {
            errors.rejectValue("price", null, "debe ser un valor mayor o igual que 500!");
        }
    }

}

En el controller, en los métodos post y put, antes del hasFieldErrors():
validation.validate(product, result);


-Un archivo con @interface es una anotacion

-Crear anotaciones personalizadas:

En un package validation:

IsRequired:
@Constraint(validatedBy = RequiredValidation.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD })
public @interface IsRequired {
    String message() default "es requerido usando anotaciones";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

}

RequiredValidation:

public class RequiredValidation implements ConstraintValidator<IsRequired, String> {

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // return (value != null && !value.isBlank());
        return StringUtils.hasText(value);

    }

}

En Product:

    // @NotBlank(message = "{NotBlank.product.description}")
    @IsRequired
    private String description;

    // @NotEmpty(message = "{NotEmpty.product.name}")
    @IsRequired(message = "{IsRequired.product.name}")
    @Size(min = 3, max = 20)
    private String name;